package storage

import (
	"errors"
	"fmt"
	"sort"

	"github.com/docker/distribution/context"
	storageDriver "github.com/docker/distribution/registry/storage/driver"
)

// Walker represents a convenient interface for reading files from
// a storage. Successive calls to the Walk method will step through
// the files and its subdirectories in lexographic order.
//
// Walking stops at EOF, or the first error from the driver. If it
// was an error from the driver, you can continue calling Walk for
// the following files.
type Walker interface {
	// Walk advances Walker to the next file, which will then be
	// available through the FileInfo method. It returns false when
	// the walk stops, either by reaching the end of the storage or
	// an error that occurred during walking.
	Walk() bool

	// FileInfo returns the most recent file generated by a call to
	// Walk.
	FileInfo() storageDriver.FileInfo

	// Err returns the first error that was encountered by the Walker.
	Err() error

	// SkipDir advances Walker to the file after the next file,
	// skipping the file that it was on.
	SkipDir()
}

type walker struct {
	ctx        context.Context
	subWalker  Walker
	driver     storageDriver.StorageDriver
	children   []string
	childIndex int
	fileInfo   storageDriver.FileInfo
	err        error
	skipDir    bool
}

// NewWalker returns a new Walker to read files from storage
// using the given storage driver.
func NewWalker(ctx context.Context, driver storageDriver.StorageDriver, from string) Walker {
	children, err := driver.List(ctx, from)
	sort.Stable(sort.StringSlice(children))

	return &walker{
		ctx:      ctx,
		driver:   driver,
		children: children,
		err:      err,
	}
}

func (w *walker) Walk() bool {
	// Walk subdirectories first
	if w.subWalker != nil {
		if w.subWalker.Walk() {
			return true
		}
		w.subWalker = nil
	}

	if w.childIndex == len(w.children) {
		return false
	}

	if w.skipDir {
		w.skipDir = false
		return false
	}

	child := w.children[w.childIndex]
	w.childIndex++

	// TODO(stevvooe): Calling driver.Stat for every entry is quite
	// expensive when running against backends with a slow Stat
	// implementation, such as s3. This is very likely a serious
	// performance bottleneck.
	if w.fileInfo, w.err = w.driver.Stat(w.ctx, child); w.err != nil {
		return false
	}

	if w.fileInfo.IsDir() && !w.skipDir {
		w.subWalker = NewWalker(w.ctx, w.driver, child)
	}

	return true
}

func (w *walker) FileInfo() storageDriver.FileInfo {
	if w.subWalker != nil {
		// Only return FileInfo from a subwalker only if it has walked
		// at least once.
		if fileInfo := w.subWalker.FileInfo(); fileInfo != nil {
			return fileInfo
		}
	}

	return w.fileInfo
}

func (w *walker) Err() error {
	if w.subWalker != nil {
		// Only return Err from a subwalker only if it has walked at
		// least once.
		if err := w.subWalker.Err(); err != nil {
			return err
		}
	}

	return w.err
}

func (w *walker) SkipDir() {
	if w.subWalker != nil {
		w.subWalker.SkipDir()
	} else {
		w.skipDir = true
	}
}

// ErrSkipDir is used as a return value from onFileFunc to indicate that
// the directory named in the call is to be skipped. It is not returned
// as an error by any function.
var ErrSkipDir = errors.New("skip this directory")

// WalkFn is called once per file by Walk
// If the returned error is ErrSkipDir and fileInfo refers
// to a directory, the directory will not be entered and Walk
// will continue the traversal.  Otherwise Walk will return
type WalkFn func(fileInfo storageDriver.FileInfo) error

// Walk traverses a filesystem defined within driver, starting
// from the given path, calling f on each file
func Walk(ctx context.Context, driver storageDriver.StorageDriver, from string, f WalkFn) error {
	children, err := driver.List(ctx, from)
	if err != nil {
		return err
	}
	sort.Stable(sort.StringSlice(children))
	for _, child := range children {
		// TODO(stevvooe): Calling driver.Stat for every entry is quite
		// expensive when running against backends with a slow Stat
		// implementation, such as s3. This is very likely a serious
		// performance bottleneck.
		fileInfo, err := driver.Stat(ctx, child)
		if err != nil {
			return err
		}
		err = f(fileInfo)
		skipDir := (err == ErrSkipDir)
		if err != nil && !skipDir {
			return err
		}

		if fileInfo.IsDir() && !skipDir {
			if err := Walk(ctx, driver, child, f); err != nil {
				return err
			}
		}
	}
	return nil
}

// pushError formats an error type given a path and an error
// and pushes it to a slice of errors
func pushError(errors []error, path string, err error) []error {
	return append(errors, fmt.Errorf("%s: %s", path, err))
}
