package storage

import (
	"errors"
	"io"
	"path"
	"strings"

	"github.com/docker/distribution/context"
	storageDriver "github.com/docker/distribution/registry/storage/driver"
)

// ErrFinishedWalk is used when the called walk function no longer wants
// to accept any more values.  This is used for pagination when the
// required number of repos have been found.
var ErrFinishedWalk = errors.New("finished walk")

// RepositoryWalker represents a convenient interface for reading
// repositories from a storage. Successive calls to the Walk method
// will step through the repositories in lexographic order.
//
// Walking stops after reading the last repository, or the first error
// from the driver. If it was an error from the driver, you can continue
// calling Walk for the following repositories.
type RepositoryWalker interface {
	// Walk advances RepositoryWalker to the next repository, which will
	// then be available through the Repository method. It returns false
	// when the walk stops, either by reaching the end of the storage or
	// an error that occured during walking.
	Walk() bool

	// Repository returns the most recent repository generated by a call
	// to Walk.
	Repository() string

	// Err returns the first error that was encountered by the walker.
	Err() error
}

type repositoryWalker struct {
	ctx        context.Context
	last       string
	root       string
	walker     Walker
	repository string
	err        error
}

// NewRepositoryWalker returns a new walker to read repositories
// from storage using the given storage driver.
func NewRepositoryWalker(ctx context.Context, driver storageDriver.StorageDriver, last string) RepositoryWalker {
	var err error

	root, err := pathFor(repositoriesRootPathSpec{})
	walker := NewWalker(ctx, driver, root)

	return &repositoryWalker{
		ctx:    ctx,
		last:   last,
		root:   root,
		walker: walker,
		err:    err,
	}
}

func (rw *repositoryWalker) Walk() bool {
	for rw.walker.Walk() {
		filePath := rw.walker.FileInfo().Path()

		// lop the base path off
		repoPath := filePath[len(rw.root)+1:]

		_, file := path.Split(repoPath)
		if strings.HasPrefix(file, "_") {
			rw.walker.SkipDir()
			if file == "_layers" {
				repoPath = strings.TrimSuffix(repoPath, "/_layers")
				if pathGreaterThan(repoPath, rw.last) {
					rw.repository = repoPath
					return true
				}
			}
		}
	}

	rw.err = rw.walker.Err()
	return false
}

func (rw *repositoryWalker) Repository() string {
	return rw.repository
}

func (rw *repositoryWalker) Err() error {
	return rw.err
}

// Returns a list, or partial list, of repositories in the registry.
// Because it's a quite expensive operation, it should only be used when building up
// an initial set of repositories.
func (reg *registry) Repositories(ctx context.Context, repos []string, last string) (n int, err error) {
	var foundRepos []string

	if len(repos) == 0 {
		return 0, errors.New("no space in slice")
	}

	repositoryWalker := NewRepositoryWalker(ctx, reg.blobStore.driver, last)
	for repositoryWalker.Walk() {
		repo := repositoryWalker.Repository()
		foundRepos = append(foundRepos, repo)

		// if we've filled our array, no need to walk any further
		if len(foundRepos) == len(repos) {
			if repositoryWalker.Walk() {
				n = copy(repos, foundRepos)
				return n, nil
			}

			break
		}
	}

	err = repositoryWalker.Err()
	if err == nil {
		err = io.EOF
	}

	n = copy(repos, foundRepos)
	return n, err
}

// Enumerate applies ingester to each repository
func (reg *registry) Enumerate(ctx context.Context, ingester func(string) error) error {
	repositoryWalker := NewRepositoryWalker(ctx, reg.blobStore.driver, "")
	for repositoryWalker.Walk() {
		repo := repositoryWalker.Repository()
		if err := ingester(repo); err != nil {
			return err
		}
	}

	err := repositoryWalker.Err()
	return err
}

func pathGreaterThan(pathX, pathY string) (b bool) {
	splitPathX := strings.SplitN(pathX, "/", 2)
	splitPathY := strings.SplitN(pathY, "/", 2)

	if splitPathX[0] == splitPathY[0] {
		if len(splitPathX) == 1 && len(splitPathY) == 1 {
			return false
		} else if len(splitPathX) == 1 && len(splitPathY) != 1 {
			return false
		} else if len(splitPathX) != 1 && len(splitPathY) == 1 {
			return true
		}

		return pathGreaterThan(splitPathX[1], splitPathY[1])

	}

	return splitPathX[0] > splitPathY[0]
}
