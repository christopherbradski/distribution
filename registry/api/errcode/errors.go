package errcode

import (
	"encoding/json"
	"fmt"
	"strings"
)

// ErrorCoder is the base interface for ErrorCode and Error allowing
// users of each to just call ErrorCode to get the real ID of each
type ErrorCoder interface {
	ErrorCode() ErrorCode
}

// ErrorCode represents the error type. The errors are serialized via strings
// and the integer format may change and should *never* be exported.
type ErrorCode int

// ErrorCode just returns itself
func (ec ErrorCode) ErrorCode() ErrorCode {
	return ec
}

// Error returns the ID/Value
func (ec ErrorCode) Error() string {
	return ec.Descriptor().Value
}

// Descriptor returns the descriptor for the error code.
func (ec ErrorCode) Descriptor() ErrorDescriptor {
	d, ok := errorCodeToDescriptors[ec]

	if !ok {
		return ErrorCodeUnknown.Descriptor()
	}

	return d
}

// String returns the canonical identifier for this error code.
func (ec ErrorCode) String() string {
	return ec.Descriptor().Value
}

// Message returned the human-readable error message for this error code.
func (ec ErrorCode) Message() string {
	return ec.Descriptor().Message
}

// MarshalText encodes the receiver into UTF-8-encoded text and returns the
// result.
func (ec ErrorCode) MarshalText() (text []byte, err error) {
	return []byte(ec.String()), nil
}

// UnmarshalText decodes the form generated by MarshalText.
func (ec *ErrorCode) UnmarshalText(text []byte) error {
	desc, ok := idToDescriptors[string(text)]

	if !ok {
		desc = ErrorCodeUnknown.Descriptor()
	}

	*ec = desc.Code

	return nil
}

// WithDetail creates a new Error struct based on the passed-in info and
// set the Detail property appropriately
func (ec ErrorCode) WithDetail(detail interface{}) Error {
	if err, ok := detail.(error); ok {
		detail = err.Error()
	}

	return Error{
		Code:   ec,
		Detail: detail,
	}
}

// Error provides a wrapper around ErrorCode with extra Details provided.
type Error struct {
	Code   ErrorCode   `json:"code"`
	Detail interface{} `json:"detail,omitempty"`
}

// ErrorCode returns the ID/Value of this Error
func (e Error) ErrorCode() ErrorCode {
	return e.Code
}

// Error returns a human readable representation of the error.
func (e Error) Error() string {
	return fmt.Sprintf("%s: %s",
		strings.ToLower(strings.Replace(e.Code.String(), "_", " ", -1)),
		e.Code.Message())
}

// Message returned the human-readable error message for this Error
func (e Error) Message() string {
	return e.Code.Message()
}

// ErrorDescriptor provides relevant information about a given error code.
type ErrorDescriptor struct {
	// Code is the error code that this descriptor describes.
	Code ErrorCode

	// Value provides a unique, string key, often captilized with
	// underscores, to identify the error code. This value is used as the
	// keyed value when serializing api errors.
	Value string

	// Message is a short, human readable decription of the error condition
	// included in API responses.
	Message string

	// Description provides a complete account of the errors purpose, suitable
	// for use in documentation.
	Description string

	// HTTPStatusCode provides the http status code that is associated with
	// this error condition.
	HTTPStatusCode int
}

// ParseErrorCode returns the value by the string error code.
// `ErrorCodeUnknown` will be returned if the error is not known.
func ParseErrorCode(value string) ErrorCode {
	ed, ok := idToDescriptors[value]
	if ok {
		return ed.Code
	}

	return ErrorCodeUnknown
}

// Errors provides the envelope for multiple errors and a few sugar methods
// for use within the application.
type Errors []error

func (errs Errors) Error() string {
	switch len(errs) {
	case 0:
		return "<nil>"
	case 1:
		return errs[0].Error()
	default:
		msg := "errors:\n"
		for _, err := range errs {
			msg += err.Error() + "\n"
		}
		return msg
	}
}

// Len returns the current number of errors.
func (errs Errors) Len() int {
	return len(errs)
}

// outboundJSONError extends Error with 'Message' so that we can include the
// error text, just in case the receiver of the JSON doesn't have this
// particular ErrorCode registered
type outboundJSONError struct {
	Code    ErrorCode   `json:"code"`
	Message string      `json:"message"`
	Detail  interface{} `json:"detail,omitempty"`
}

// MarshalJSON converts slice of error, ErrorCode or Error into a
// slice of Error - then serializes
func (errs Errors) MarshalJSON() ([]byte, error) {
	var tmpErrs struct {
		Errors []outboundJSONError `json:"errors,omitempty"`
	}

	for _, daErr := range errs {
		var err Error

		switch daErr.(type) {
		case ErrorCode:
			err = daErr.(ErrorCode).WithDetail(nil)
		case Error:
			err = daErr.(Error)
		default:
			err = ErrorCodeUnknown.WithDetail(daErr)

		}

		tmpErrs.Errors = append(tmpErrs.Errors, outboundJSONError{
			Code:    err.Code,
			Message: err.Message(),
			Detail:  err.Detail,
		})
	}

	return json.Marshal(tmpErrs)
}

// inboundJSONError is like outboundJsonError except it leaves 'Code'
// as a string so that we can register unknown codes appropriately
type inboundJSONError struct {
	Code    string      `json:"code"`
	Message string      `json:"message"`
	Detail  interface{} `json:"detail,omitempty"`
}

// UnmarshalJSON deserializes []Error and then converts it into slice of
// Error or ErrorCode
func (errs *Errors) UnmarshalJSON(data []byte) error {
	var tmpErrs struct {
		Errors []inboundJSONError
	}

	if err := json.Unmarshal(data, &tmpErrs); err != nil {
		return err
	}

	var newErrs Errors
	for _, daErr := range tmpErrs.Errors {
		// Make sure this ErrorCode is registered, and if not register it
		desc, ok := idToDescriptors[daErr.Code]
		if !ok {
			desc = ErrorDescriptor{
				Value:          daErr.Code,
				Message:        daErr.Message,
				Description:    "unknown",
				HTTPStatusCode: ErrorCodeUnknown.Descriptor().HTTPStatusCode,
			}
			desc = Register("unknown", desc).Descriptor()
		}

		if daErr.Detail == nil {
			// Error's w/o details get converted to ErrorCode
			newErrs = append(newErrs, desc.Code)
		} else {
			// Error's w/ details are untouched
			newErrs = append(newErrs, Error{
				Code:   desc.Code,
				Detail: daErr.Detail,
			})
		}
	}

	*errs = newErrs
	return nil
}
